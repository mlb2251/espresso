

Expr: # something that can be assigned to or returned directly
    BnfCall(name:str,args:str)# -> "p.{name}({args})"
    Or(left:Expr,right:Expr) # same as GeneralOr but each branch is a single expr
    MacroCall(name:str,args:[Expr])
    Maybe(items:Expr) # evals to a bool
    Quoted(val:str) # trivially translated to Regex. oh wait not totally trivial insert escapes where needed
    Regex(re:str,control:[str]) # regexes yield the entire string they capture (unless `control` says otherwise)
    KleenePlus(val:Expr])
    KleeneStar(val:Expr)
    Asn(name:str,val:Expr)# -> "{name} = {val}"
    Seq(items:[Expr])



#
# Seq -> fn() but first `def fn` side effect
# Or -> 
# KPlus -> 
# Asn -> 


# everything is an expression but some expressions (like Seq w len > 1) eval to UNDEF

# b.append(pynode_stmt)
# b.desugar(mynode)
# should .parse be .parse(text,type=object)? Then it could even do unwrapping/wrapping for singleton Suites and such

# todo:
# Node.tuple
# Node.parent(cls=object)
# rename "Stmt" to smtg else more relevant...
# logical_xor keeping track of what almost succeeded
# defaults for FuncDef(fname=name) etc
# Var/FuncDef.path should give a name that references the var/func. This can just be done in terms of globals() to avoid local overrides.
# left_recursion autodetection (for bnf itself too!)
# note that "*" is more than you think. it's greedy but you fail later it'll backtrack and try a shorter match. Perhaps thats not needed for this though?

Production(items:Seq,rhs:str?)
Decorator(name:str)

BnfFn(name:str,argnames:[str],rules:[Production],decos:[Decorator])
MacroFn(name:str,argnames:[str],rules:[Production],decos:[Decorator])
PdefFn(text:str)

